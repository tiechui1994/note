# linux exec与重定向

exec 属于 bash 内部命令(shell builtin).

linux bash shell 命令分为两类: 内部命令和外部命令. 外部命令是通过系统调用或独立的程序实现的. 如sed, find等. 内部命令
是由特殊的文件格式(.def)所实现. 如cd, exec, history等

### fork 基本概念

fork 是 linux 的系统调用, 用于创建子进程(child process). 子进程是父进程的一个副本, 从父进程那里获得一定资源分配以及
继承父进程的环境. 子进程与父进程唯一不同的地方在于pid.

环境变量(传递给子进程的变量)只能单向从父进程传给子进程. 不管子进程的环境变量如何变化, 都不会影响父进程的环境变量.

shell script执行方式: 一是产生一个shell, 然后执行相应的script. 二是在当前shell下执行, 不再启用其他shell.

针对方法一, 需要在 script 开头加上 `#!/bin/bash` 或 `#!/usr/bin/env bash`, 然后执行脚本.

针对方法二, 可以使用 source 命令, 这时不再产生新的 shell, 而是在当前 shell 下执行命令.

- source

source 命令即点(.)命令. source命令是在当前进程中执行参数文件当中的命令, 而不用另起子进程.

- exec

exec 命令在执行时会把当前的 shell process关闭, 然后切换到参数命令继续执行.

系统调用 exec 是以新的进程去代替原来的进程, 但进程的pid保持不变. 因此, 可以认为 exec系统调用并没有产生新的进程, 只是
替换了原来进程的上下文的内容. 原进程的代码段, 数据段, 堆栈段被新的进程所代替.

> 进程主要包含的内容:
> 1.一个进程可以执行的程序
> 2.与进程关联的数据(包括变量,内存,缓冲区)
> 3.程序上下文(程序计数器PC, 保存程序执行的位置)

执行 exec 系统调用, 一般是这样的: 首先使用 fork() 函数新创建一个进程, 然后让进程去执行 exec 调用. 在 fork() 建立新
进程之后, 父进程和子进程共享代码段, 但是数据段是分开的, 但父进程会把自己的数据空间的内容 copy 到子进程去, 还有上下文也会
copy 到子进程. 然而为了提高效率, 采用一种COW的策略, 即创建子进程的时候, 并不copy父进程的地址空间, 父子进程使用相同的地
址空间, 只有当子进程需要写入数据时, 这时才会复制地址空间, 然后复制数据到子进程中. 从而父子进程拥有独立的地址空间.

exec 与 system 的区别:

exec 是直接用新的进程去代替原来的进程运行, 运行完毕之后不会回到原先的程序中去.

system 是调用 shell 执行命令, system=fork+exec+waitpid, 执行完毕之后, 回到原来的程序中去. 继续执行后面的内容.

### 基本概念

I/O重定向通常与FD相关. shell的FD通常为10个, 即0~9

三个常用的FD: 0, 标准输入; 1, 标准输出; 2, 标准错误输出.

bash 执行命令过程: 分析命令 - 变量求值 - 命令替换('``' 和 '$()') - 重定向 - 通配符展开 - 确定路径 - 执行命令.

'()' 将 command group 置于 sub-shell 去执行, 也称为 nested sub-shell. 它有个非常重要的特性: 继承父shell的标准
输入, 标准输出, 标准错误输出和其他打开的fd.

exec 常用语替代当前 shell 并重新启动一个 shell. 换言之, 并没有启动子 shell, 使用 exec 时会清除现有环境. **exec
在对文件描述符进行操作时, 也只有这时, exec不会覆盖当前的shell环境.**

### 常用重定向

```
`cmd &n` 使用系统调用 dup 复制文件描述符 n, 并把其用作标准输出.

`&-` 关闭标准输出

`n&-` 将文件描述符 n 关闭.


fd> filename,  

old>&new, old和new都是文件描述符. 如果old缺省, 默认值是1. 将 old 文件描述符重定向到 new

```



