# 文件

## 文件权限

- 文件权限

字母`rwxXst`为受影响的用户选择文件mode: 

- 读(r), 

- 写(w), 

- 执行(或搜索目录)(x), 

- 仅当文件是目录或已经对某些文件具有执行权限时才`执行/搜索`用户(X), 在执行时

- 在执行时设置UID或GID (s), 对于文件, 当文件是一个可执行文件时, 有效UID(GID)将从实际UID(GID)设置成该程序所有者的
UID(GID); 对于目录, 如果对目录设置setgid位, 那么在该目录下创建的文件/目录都将属于"该目录所在组", 而不是属于"文件创建
者所在组".

> 默认情况下, 创建一个文件(目录), 其组是文件(目录)拥有者的组. 但是可以通过 chown 修改文件(目录)的组.

- 限制删除标志或沾滞位 (t), 主要是针对目录而言. 它可以防止非特权用户删除或重命名该目录中的文件, 除非他们拥有该文件或目录.
"/tmp" 的权限就是 "rwxrwxrwt", 最后一个是"t"是沾滞位

- 文件和目录当中对于权限的含义

同一个权限对于 `文件` 和 `目录` 来说, 含义是不一样的.

| 权限 | 文件 | 目录 |
| --- | --- | --- |
| r | 可以读取文件内容	| 可以读取目录结构列表 |
| w	| 可以编辑修改文件内容 | 可以改动目录结构列表 |
| x	| 可以被系统执行 |	用户可以进入目录 (cd) |

> 注意: **可以改动目录结构列表**, 意味着:
> 
> - 建立新的文件与目录
> - 删除已存在的文件与目录
> - 将已存在的文件或目录进行更名
> - 搬移该目录内的文件, 目录位置

## 文件压缩

- tar

tar 命令不是专门的压缩命令. 它通常用于将多个文件拉入一个单个文件中, 以便容易地传输到另一个系统, 或者将文件作为一个相关的
组进行备份. 它也提供了压缩的功能, 附加一个 `z` 压缩选项能够实现压缩文件.

1) 当使用 `z` 选项为 tar 命令附加压缩的过程时, tar 使用 `gzip` 来进行压缩.

2) 当使用 `j` 选项为 tar 命令附加压缩的过程时, tar 使用 `bzip2` 来进行压缩.

3) 当使用 `J` 选项为 tar 命令附加压缩的过程时, tar 使用 `xz` 来进行压缩.

压缩:
```
tar cfz file.tgz file1 file2 ...

tar cfj file.tar.bz2 file1 file2 ...

tar cfJ file.tar.xz file1 file2 ...
```

解压:
```
tar xfz file.tar.gz

tar xfj file.tar.bz2

tar xfJ file.tar.xz

tar xf file.tar.xxx # 通用解压缩
```

- zip

zip 命令创建一个压缩文件, 与此同时保留原始文件的完整性. 语法和 `tar` 一样简单, 只是必须记住, 原始文件名称应该是命令行
上的最后一个参数.

压缩:
```
zip file.zip file1 file2 ...
```

解压:
```
unzip file.zip
```

- gzip

gzip 命令非常容易使用, 只需要输入 gzip, 紧跟之后的是要压缩的文件. gzip 将 "就地" 压缩文件. 换句话说, 原始文件将被压
缩文件所替换.

压缩:
```
gzip file1 file2 ...
```

解压:
```
gunzip file.gz

gzip -d file.gz
```

- bzip2

像使用 gzip 命令一样, bzip2 将选择的文件 "就地" 压缩, 不留下原始文件. 

压缩:
```
bzip2 file file2 ...
```

解压:
```
bunzip2 file.bz2

bzip2 -d file.bz2
```


- xz

xz 和 `gzip`, `bzip2` 一样, 将选择的文件 "就地" 压缩, 不留下原始文件.

压缩:
```
xz file file2 ...
```

解压:
```
unxz file.xz

xz -d file.xz
```

> gzip, bzip2, xz 共同的选项:
> - `-d, --decompress` 表示解压缩文件
> - `-t, --test` 表示测试压缩文件
> - `-k, --keep` 表示保持源文件, 不删除. 

## 硬链接与软连接的联系与区别

文件都有文件名和数据, 这在Linux上被分为两部分: 用户数据(user data) 与 元数据(metadata). 用户数据, 即文件数据块(
data block), 数据块是记录文件真实内容的地方; 元数据是文件的附加信息, 如文件大小, 创建时间, 所有者等信息. 在Linux中, 
元数据中的inode号(inode是文件元数据的一部分但其实不包含文件名, inode号即索引节点号)才是文件的唯一标识而非文件名.


Linux系统中查看inode号可使用stat或ls -i.

为了解决文件的共享使用, Linux系统引入了两种链接: 硬链接(hard link)与软连接(又称符号链接,即soft link或symbolic link)
链接为Linux系统解决了文件的共享使用, 还带来了隐藏文件路径, 增加权限安全以及节省存储等好处. 若一个inode号对应多个文件名, 
则称这些文件为硬链接. 换言之, 硬链接就是同一个文件使用了多个别名.


硬链接的特性:

- 文件有相同的inode及data block, 权限(ower, rwx)
- 只能对已存在的文件进行创建;
- 不能交叉文件系统进行硬链接的创建;
- 不能对目录进行创建, 只可对文件创建;
- 删除一个硬链接文件并不影响其他有相同inode号的文件


文件old.file与hard.link有着相同的inode号及文件权限. inode是随着文件的存在而存在, 因此只有当文件存在时才可创建硬链接,
即当inode存在且链接计数器(Links)不为0时. 

inode号仅在各文件系统下是唯一的, 当Linux挂载多个文件系统后将出现inode号重复的现象, 因此硬链接创建时不可跨文件系统.


硬链接不能对目录创建是受限于文件系统的设计. 现Linux文件系统中的目录均隐藏了两个特殊的目录: 当前目录(.) 和 父目录(..).
查看这两个特殊目录的inode号可知其实这两个目录就是两个硬链接. 若系统允许对目录创建硬链接, 则会产生目录环.

> . 目录的硬链接数量的2 (当前目录下的 . 和 在父目录下的目录)
> .. 目录的硬链接数量是2+n n是当前目录下的子目录的个数


软连接与硬链接不同, 若文件用户数据块中存放的内容是另一文件的路径名的指向, 则该文件就是软连接. 软连接就是一个普通文件,只是
数据块内容有点特殊. 软连接有着自己的inode号以及用户数据块. 因此软连接的创建与使用没有类似硬链接的诸多限制:

- 软连接有自己的文件属性及权限等(数据块的大小是0);
- 可对不存在的文件或目录创建软连接;
- 软连接可交叉文件系统;
- 软连接可对文件或目录创建;
- 创建软连接时, 链接计数i_nlink不会增加;
- 删除软连接并不影响被指向的文件, 但若被指向的原文件被删除, 则相关软连接被称为死链接(即dangling link)

软链接数据访问:

![image](/images/linux_link_softlink_access.jpg)


当然软连接的用户数据也可以是另一个软连接的路径, 其解析过程是递归的. 但需要注意: 软连接创建时原文件的路径指向使用绝对路径较
好. 使用相对路径创建的软连接被移动后该软链接将会成为一个死链接.
