# Linux 下的内存管理

程序内存地址 => 虚拟内存 => 物理内存


## Linux 虚拟内存和物理内存的理解

1.每个进程的4G内存空间是虚拟内存空间, 每次访问内存空间的某个地址, 都需要把地址翻译为实际物理内存地址.

2.所有进程共享同一物理内存, 每个进场只把自己目前需要的虚拟内存空间映射并存储到物理内存上.

3.进场要知道哪些内地址上的数据在物理内存上, 哪些不在, 还有在物理内存上的那些, 需要用 `页表` 来记录.

> 页表的每一个表项分两部分: 第一部分记录此页是否在物理内存上, 第二部分记录物理内存页的地址(如果存在)

4.当进程访问某个虚拟地址时, 去查询页表, 如果发现对应的数据不在物理内存中, 则产生 `缺页中断`.

> 缺页中断的处理过程, 就是把进程需要的数据从磁盘上拷贝到物理内存中, 如果内存已经满了, 没有空地方联动, 那就找一个页进行
> 覆盖, 当然如果被覆盖的页曾经被修改过, 需要讲此页写回磁盘.

![image](resource/mem_overwrite.png)


> **优点:**
> 
> - 既然每个进程的内存空间都是一致且固定的, 所以 *链接器在链接可执行文件时, 可以设定内存地址*, 而不用去管这些数据最终
> 实际的内存地址, 这是有独立内存空间的好处.
> - 当不同的进程使用同样的代码时, 比如库文件的代码, *物理内存中可以只存储一份*这样的代码, 不同的进场只需要把自己的虚拟
> 内存映射过去就可以了, 节省内存.
> - 当程序*需要分配连续的内存空间*的时候, 只需要在虚拟内存空间分配连续空间, 而不需要实际物理内存的连续空间, 可以利用碎
> 片.


## 处理器内核(软核)是否带有 MMU 单元

> MMU (内存映射单元), 通常是CPU的一部分, **本身有少量的存储空间**来存放从虚拟地址到物理地址的查找表; 所有数据请求都
> 送往MMU, 由MMU决定数据是在RAM内还是在大容量存储设备内; 也能将用用程序的执行对应到不同虚拟内存的空间中, 让操作系统提
> 供内存保护.

### MMU 功能

- 在 Linux 的运行环境中, MMU是必不可少的重要单元. 如果没有MMU对 memory 进行管理, 那么操作吸引面对的是单一的物理地址,
如果地址线是32位, 那么操作系统能够管理的只有 4 GB 空间, 正是引入 MMU:

> - 操作系统可使用虚拟地址来进行映射
> - MMU 的地址翻译和地址保护

- Linux 操作系统在运行过程中, 会涉及虚拟地址到物理地址的转换, 这就是 MMU 功能模块完成的任务.

### MMU 工作原理

- 如果软件需要控制 MMU, 需要通过系统内部的协处理器对某些寄存器进行读操作, 来获取MMU的状态; 通过向某些寄存器发起写操作
来控制 MMU 的操作

- MMU 单元可以提供全面的内存管理(`执行多任务程序需要的地址装换和权限检查`), 因此多用户应用程序可以在这个 CPU 内核的支
持下运行.

- 在打开 MMU 功能模块后, 它对数据池和指令池发出的地址称为虚拟地址:

> - 在内存中找到该地址域对应的转换页, 把虚拟地址的高位部分替换, 形成可以访问内存, 寄存器的物理地址.
> - 在这些`转换页`中, 有对该部分地址域限定的权限信息. 结合处理器的当前状态, 这些转换页提供的权限信息即可让处理器判断此
> 次的读写访问是否合法:
> 1.如果合法, 处理器会在存储空间中按照物理地址进行读写操作
> 2.如果非法, 处理器会发出数据访问或指令读取异常标志, 这些标志信号将引导处理器进入异常中断向量中.

- 现代操作系统普遍采用虚拟内存管理机制, 这需要MMU的支持. MMU 通常是CPU的一部分, 如果处理器没有MMU, 或者`有MMU但没有
启用`, **CPU执行单元发出的内存地址将直接传到芯片引脚上**, 被`内存芯片(物理内存)`接收, 这里的地址称为物理地址. 如果
处理器启用了 MMU, **CPU执行单元发出的内存地址将被MMU截获**, 从 CPU 到 MMU 的地址称为虚拟地址. 而MMU将这个地址翻
译成另一个地址发送到CPU芯片的外部地址引脚上, 也就是将虚拟地址转换为物理地址.

![image](resource/mmu.png)


## 硬件页表 vs 软件页表

- `现在Linux内核是 4 级页表结构, 3级页表结构的时代是10年前了`.

- X86_64 架构下, 无论是 Intel 还是 AMD 的 CPU, 都是4级的硬件页表, 所以软件层面的页表至少要 4 级(否则, 进程访问的
空间将受限, 因为有一级虚拟页表被固定住了, 3级页表, X86_64只能访问 512 GB 空间, 4级页表, X86_64的可访问空间达到了
31072(2^47)GB)

- i386 只有三级硬件页表: PUD -> PMD -> PTE. `怎么嵌入四级页表结构? 答案是虚设一级`

> - 用户空间虚拟地址, 按照上述的四级进行翻译
> - 内核空间虚拟地址是所有进场共享的, 重要的是, 从效率角度看, 如果同样走四级页表翻译的流程, 速度太慢. 于是, 内核初始化
> 时, 就创建内核空间的映射(因为所有进程共享, 有一份就足够了), 并且, `采用线性映射`, 而不是走页表翻译这种类似哈希表的方
> 式.
> - `为什么用户空间不能也像内核空间这么做`? 用户地址空间是随进场创建才产生的, 它的页面可能散步在不同的物理内存中, 无法
> 这么做. 另外, 走页表的过程, 不止是翻译的过程, 还是一个权限检查的过程, 对于不可控的用户态地址, 这样的安全性检查必不可
> 少. 而内核空间, 只有一份, 所有可以提前固定下来一片连续的物理地址空间, 按线性方法映射 (按前面的线性方法, 1G内核空间,
> 只能映射1G物理地址空间, 这对内核来说, 太掣肘了; Linux内核只对1G内核空间的前 896 M 按前面所说的方法线性映射, 剩下的
> 128M 的内核空间 `[高端内存]`, 采用动态映射的方式, 即按需映射的方式, 这样内核态的访问空间更多了).


