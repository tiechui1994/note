# TCP 拥塞控制

拥塞控制的目的是避免 `[发送方]` 的数据填满整个网络.

为了在 `[发送方]` 调节所要发送数据的量, 定义了一个叫做 `[拥塞窗口]` 的概念.

**拥塞窗口 cwnd** 是发送方维护的一个状态变量, 它会根据**网络的拥塞程度动态变化的**.

在流量控制时提到了发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系, 那么由于加入了拥塞窗口的概念后, 此时发送窗口的
值是 swnd = min(rwnd, cwnd), 也就是拥塞窗口和接收窗口中的最小值.

拥塞窗口 cwnd 变化的规则:

- 只要网络中没有出现拥塞, cwnd 就会增大;
- 网络中出现了拥塞, cwnd 就减少;

> 如何确定当前的网络出现了拥塞?

只要 `发送方` 没有在规定时间内接收到 ACK 应答报文, 也就是**发生了超时重传, 就会认为网络出现了拥塞**.

> 拥塞控制有哪些控制算法?

- 慢启动
- 拥塞避免
- 拥塞发生

### 慢启动

TCP 刚建立连接完成后, 首先是有个慢启动的过程, 这个慢启动的意思是一点一点的提高发生数据包的数量.

慢启动算法的规则: **当发送方每收到一个 ACK, 拥塞窗口 cwnd 的大小就加 1**.

假定拥塞窗口 `cwnd` 和发送窗口 `swnd` 相等. 例子:

- 连接建立完成后, 一开始初始化 `cwnd = 1`, 表示可以传一个 `MSS` 大小的数据.

- 当收到一个 ACK 确认应答后, cwnd 增加 1, 于是一次性能够发送 2 个.

- 当这 2 个的 ACK 确认应答后, cwnd 增加 2, 于是一次性能够发送 2 个.

- 当这 4 个的 ACK 确认应答后, 每个确认 cwnd 增加 1, 4 个确认 cwnd 增加 4. 依次类推...

慢启动算法变化过程:

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/27.jpg)

**慢启动算法, 发包的个数是呈现指数性的增长.**

> 慢启动增长的上限是什么?

有一个叫做慢启动门限 `ssthresh` (slow start threshold) 状态变量. 定义了拥塞窗口的上限.


- 当 `cwnd` < `ssthresh` 时, 使用慢启动算法.
- 当 `cwnd` >= `ssthresh` 时, 就会使用 `拥塞避免算法`.

### 拥塞避免算法

一般来说 `ssthresh` 的大小是 `65535` 字节.

拥塞避免算法, 它的规则是: **每当收到一个 ACK 时, cwnd 增加 1/cwnd**.

接着慢启动的例子, 假设 `ssthresh` 是 8.

- 当 8 个 ACK 应答确认到来时, 每个确认增加 1/8, 8 个 ACK 确认 cwnd 一共增加 1, 于是这一次能够发送 9 个 MSS 大小
的数据, 变成了**线性增长**.

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/28.jpg)


**拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长**. 在一直增长过后, 网络慢慢进入了拥塞的状况, 于是就会出现
丢包现象, 这时就需要对丢失的数据包进行重传.

当触发重传机制, 就进入了拥塞发生阶段.

### 拥塞发生

网络出现拥塞, 也就是发生数据包重传, 重传机制主要有两种:

- 超时重传
- 快速重传

#### 发生超时重传的拥塞发生算法

**当发生了超时重传, 那就会使用超时重传机制**, 这个时候, ssthresh 和 cwnd 的值会发生变化:

- `ssthresh = cwnd/2`
- `cwnd` 重置为 1(是恢复为 cwnd 的初始值. 这里假定 cwnd 初始值为1)

> 怎么查看系统的 cwnd 初始值?

Linux 针对每个 TCP 连接的初始值是 10, 也就是 10 个 MSS. 可以使用 `ss -nli` 查看每一个 TCP 连接的 cwnd 初始值.

超时重传算法的变化如下:

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/29.jpg)

接着就是重新开始慢启动, 慢启动是会突然减少流量数据量的. 

#### 发生快速重传的拥塞发生算法

**当接收方发现丢了一个中间包的时候, 发生三次前一个包的ACK, 于是发送方就会使用快速重传, 不必等待超时重传**. 在这种情
况下, ssthresh 和 cwnd 变化如下:

- `cwnd = cwnd/2`
- `ssthresh = cwnd`
- 进入快速恢复算法

快速重传与快速恢复一般同时使用, 快速恢复算法是认为, 还能收到3个重复ACK, 说明网络抖动没有那么强烈.

快速恢复算法:

- 拥塞窗口 `cwnd = ssthresh + 3` (3表示3个确认数据包被收到了)
- 重传丢失的数据包;
- 如果再收到重复的 ACK, 那么 cwnd 增加 1; 
- 如果收到新数据的 ACK 后, 把 cwnd 设置为第一步中的 ssthresh 的值, 原因是该 ACK确认了新的数据, 说明从 duplicate 
ACK 时的数据都已经收到, 该恢复已经结束, 可以回到恢复之前的状态了, 也即再次进入拥塞避免状态;

快速重传算法的变化如下:

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/网络/拥塞发生-快速重传.drawio.png)

## 重传机制

超时重传机制, 就是在发送数据时, 设定一个定时器, 当超过指定的时间后, 没有收到对方的 ACK 确认应答报文, 就会重复该数据.

TCP 会在两种情况发生超时重传:

- 数据包丢失
- 确认应答丢失

关于超时时间设置问题?

RTT(Round-Trip Time 往返时延)

![image](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/计算机网络/TCP-可靠特性/6.jpg)

RTT 指的的`数据发送时刻到接收到确认的时刻差值`, 也就是包的往返时间.

超时重传时间是 RTO(Retransmission Timeout 超时重传时间) 表示.

超时时间 RTO 较长或较短时, 会有啥状况?

- 当超时时间 RTO 较大时, 重发就慢, 没有效率, 性能差;
- 到超时时间 RTO 较小时, 会导致可能并没有丢就重发, 于是重发就快, 会增加网络拥塞, 导致更多的超时.

根据上述状况, **超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**.

Linux 下 RTO 的计算方式?

估算往返时间, 通常需要采样以下连个:

- 需要 TCP 通过采样 RTT 的时间, 然后进行加权平均, 算出一个平滑 RTT 的值, 而且这个值还要不断变化的, 因为网络状况不
断地变化.
- 除了采样 RTT, 还要采样 RTT 的波动范围, 这样就避免如果 RTT 有一个大的波动的话, 很难被发现的情况.

RFC6289 推荐的 RTO 计算公式:

```
1. 计算首次 RTO, 其中 R1 为第一次测量的 RTT

SRTT = R1
DevRTT = R1/2
RTO = u*SRTT + e*DevRTT = u*R1 + e*(R1/2)

2. 后续的 RTO, 其中 R2 为最新测量的 RTT

SRTT = SRTT + a(RTT - SRTT) = R1 + a*(R2 - R1)

DevRTT = (1-b)*DevRTT + b*(|RTT - SRTT|) = (1-b)*(R1/2) + b*(|R2 - R1|)

RTO = u*SRTT + e*DevRTT 

其中 SRTT 是计算平滑的 RTT, DevRTT 是计算平滑 RTT 与最新 RTT 的差距

Linux 下, a=0.125 b=0.25 u=1 e=4
``` 

**如果超时重发的数据, 再次超时, 又需要重传时, TCP 的策略是超时间隔加倍**



