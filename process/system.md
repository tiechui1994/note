## systemd 并发启动

systemd 提供了比Upstart更激进的并行启动能力, 采用 socket/D-BS activation等技术启动服务. 显而易见的结果是更
快的启动速度. 为了减少启动时间, systemd的目标是:

- 尽可能启动更少的进程
- 尽可能将更多进程并行启动

同样地, Upstart也试图实现这两个目标. Upstart采用事件驱动机制, 服务可以暂不启动, 当需要的时候通过事件触发其启动,
这符合第一个设计目标; 此外不相干的服务可以并行启动, 这实现了第二个目标.

**systemd提供按需启动能力.**

当 `SysV` init 系统初始化的时候, 它会将所有可能用到的后台服务进程全部启动运行. 并且系统必须等待所有的服务都启动就绪
之后,  才允许用户登录. 

> tip: 某些服务很可能在很长一段时间内, 整个服务器运行期间都没有被使用过. 比如 CUPS, 打印服务在多数服务器上很少被真
> 正使用到. 花费启动这些服务上的时间是不必要的; 同样, 花费在这些服务上的系统资源也是一种浪费.


**systemd采用Linux的Cgroup特性跟踪和管理进程的生命周期.** init 系统的一个重要职责是负责跟踪和管理服务进程的生命
周期. 它不仅可以启动一个服务, 它必须也能够停止服务. 服务进程一般都作为后台进程(daemon)在后台运行, 为此服务程序有时
候会派生(fork)两次. 

在 Upstart 当中, 需要在配置文件中正确地配置 `expect` . 这样 Upstart 通过对fork系统调用进行计数, 从而获知真正的
后台进程的PID. 还有更加特殊的情况. 比如吗一个CGI程序会派生两次, 从而脱离了和Apache的父子关系. 当Apache进程被停止
后, 该CGI程序还在继续运行. 而期望是Apache服务停止后, 所有由它启动的相关进程也被停止. 为了处理这类问题, Upstart通
过strace来跟踪 fork, exit 等系统调用, 但是这种方法很笨拙, 且缺乏可扩展性. Systemd利用了Linux内核的特性即Cgroup
来完成跟踪的任务. 当停止服务时, 通过查询Cgroup, systemd可以准确找到所有的相关进程, 从而干净地停止服务.


### 依赖关系

虽然Systemd将大量的启动解除了依赖, 使得它们可以并发启动. 但还是存在有些任务, 它们之间存在天生的依赖, 不能用"Socket
activation(套接字激活)", D-BUS activation和autofs三大方法解除依赖. 比如: 挂载必须等待挂载点在文件系统中被创
建;挂载也必须等待相应的物理设备就绪. 为了解决这类依赖问题, Systemd的配置单元之间可以彼此定义依赖关系.

Systemd用配置单元定义文件中的关键字来描述配置单元之间的依赖关系. 比如: unit A 依赖unit B, 可以在unit B的定义
中使用"require A"来表示.


### Systemd的并发启动原理

Systemd的开发人员仔细研究了服务之间的相互依赖的本质问题, 发现所谓依赖可以分为三个具体的类型, 而每一个类型实际上都可
以通过相应的u技术解除依赖关系.

#### 并发启动原理之一: 解决socket依赖

绝大多数的服务依赖是套接字依赖. 比如服务A通过一个套接字端口S1提供自己的服务, 其他的服务如果需要服务A, 则需要连接S1.
因此如果服务A尚未启动, S1就不存在, 其他的服务就会得到启动错误, 所以传统地, 人们先启动服务A, 等待它进入就绪状态, 再
启动需要它的服务.

Systemd认为, 只要我们预先把S1建立好, 那么其他所有的服务就可以同时启动而无需等待服务A来创建S1了. 如果服务A尚未启动,
那么其他进程向S1发送的服务请求实际上会被Linux操作系统缓存, 其他进程会在这个请求的地方等待. 一旦服务A启动就绪, 就可
以立即处理缓存的请求, 一切都开始正常运行.

Linux操作系统有一个特性, 当进场调用fork或者exec创建子进程之后, 所有在父进程中被打开的文件句柄(file descriptor)
都被子进程所继承. 套接字也是一种文件句柄, 进程A]可以创建一个套接字, 以后当进程A调用exec启动一个新的子进程时, 只要确
保该套接字的 close_on_exec 标志位被清空, 那么新的子进程就可以继承这个套接字. 子进程看到的套接字和父进程看到的套接
字是同一个系统套接字, 就仿佛看到这个套接字是子进程自己创建的一样, 没有任何区别.

这个特性被一个叫做inetd的系统服务所利用, inetd进程会负责监控一些常用套接字端口, 比如telnet, 当该端口号有连接请求
时, inetd才启动telnetd进程, 并把有连接的套接字传递给新的telnetd进程. inetd可以代理很多的网络服务, 这样可以节约
很多的系统负载和内存资源, 只有当有真正的连接请求时才启动相应服务, 并把套接字传递给相应的服务进程.

和inetd类似, Systemd是所有其他进程的父进程, 他可以先建立所有需要的套接字, 然后在调用exec的时候将该套接字传递给新
的服务进程, 而新进程直接使用该套接字进行服务即可.


#### 并发启动原理之二: 解决D-BU依赖

D-BUS是desktop-bus的简称. 是一个低延迟,低开销,高可用性的进程间通信机制. 它越来越多地使用于应用程序之间通信, 也用
于应用程序和操作系统内核之间的通信. 很多现代的服务进程都使用D-BUS取代套接字作为进程间通信机制, 对外提供服务. 比如简
化Linux网络配置的NetworkManager服务就使用D-BUS和其他的应用程序或者服务进行交互: 邮件客户端软件evolution可以通
过D-BUS从NetworkManage服务获取网络状态的改变, 以便做出相应的处理.

D-BUS支持所谓的"bus activation"功能. 如果服务A需要使用服务B的D-BUS服务, 而服务B并没有运行, 则D-BUS可以在服务
A请求服务B的D-BUS时自启动服务B. 而服务A发出的请求会被D-BUS缓存, 服务A会等待服务B启动就绪. 利用这个特性, 依赖
D-BUS的服务就可以实现并行启动.


#### 并发启动原理之三: 解决文件系统依赖

系统启动过程中, 文件系统相关的活动是最耗时的, 比如挂载文件系统, 对文件系统进行磁盘检查(fsck), 磁盘配额检查等都是非
常耗时的操作. 在等待这些工作完成的同时, 系统处于空闲状态. 那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可
以启动.但是Systemd发现这种依赖也是可以避免的.

Systemd参考了autofs的设计思路, 使得依赖文件系统的服务和文件系统本身两者初始化可以并发工作. autofs可以检测到某个文
件系统挂载点真正被访问到的时候才触发挂载操作, 这是通过内核automounter模块的支持而实现的. 比如一个open()系统调用作
用在"/misc/cd/file1"的时候, /misc/cd尚未执行挂载操作, 此时open()调用被挂起等待, Linux内核autofs执行挂载. 这
个时候,控制权返回给open()系统调用, 并正常打开文件.

Systemd集成了autofs的实现, 对于系统中的挂载点, 比如/home, 当系统启动的时候, Systemd为其创建一个临时的自动挂载
点. 在这个时刻/home真正的挂载设备尚未启动好, 真正的挂载操作还没有执行, 文件系统检测还没有完成. 可是那些依赖该目录
的进程已经可以并发启动, 它们的open()操作被内建在Systemd中的autofs捕获, 将该ope()调用挂起(可中断睡眠状态). 然
后等待真正的挂载操作完成, 文件系统检测完成后, Systemd将该自动挂载点替换为真正的挂载点, 并让open()调用返回. 由此, 
实现了那些依赖于文件系统的服务和文件系统本身同时并发启动.

当然对于"/"目录的依赖实际上一定还是串行执行, 因为Systemd自己也存放在"/"之下, 必须等待系统根目录挂载检查好.
