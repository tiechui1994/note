## 事务

### 事务的特性

- 原子性(A)

"原子性"方面涉及到 InnoDB 事务, 相关的 MySQL 功能: `COMMIT` 语句, `ROLLBACK` 语句. 

原子性通过 undo log 实现的.

- 一致性(C)

"一致性"方面主要涉及 InnoDB 内部处理, 以防止数据崩溃. 相关 MySQL 功能: InnoDB `doublewrite buffer`, 
InnoDB `crash recovery`.

一致性是通过原子性, 持久性, 隔离性实现的. 这是数据库的终极目标.

- 隔离性(I)

"隔离性"方面涉及到 InnoDB 事务, 尤其是适合于每个事务的隔离级别. 相关 MySQL 功能: `事务隔离级别设置`, `InnoDB 锁`

隔离性是通过读写锁+MVCC实现的.

- 持久性(D)

相关的 MySQL 功能:

1) InnoDB `doublewrite buffer`
2) `innodb_flush_log_at_trx_commit`,  `sync_binlog`, `innodb_file_per_table` 变量
3) 存储设备的写缓存区.
4) 用于运行 MySQL 的 OS, 特别是对 `fsync()` 系统调用的支持.
5) 备份策略
6) MySQL 集群, 以及集群之间的网络.

持久性是通过 redo log 来实现的.

### redo_log, undo_log, mvcc

redo log(重做日志), 是用来实现事务的持久性. 该日志文件分为两部分: 重做日志缓冲(redo log buffer)以及重做日志(redo log).

redo log 作用:

1. 恢复数据的保障, 已提交事务的持久化特性.

2. redo log 的顺序写入, 提升数据库的IO性能.

undo log(回滚日志), 用于记录数据的逻辑变化, 为了在发送错误时回滚之前的操作.

undo log 作用:

1. undo log 是用来回滚数据的保障, 保证事务的原子性.


### 事务隔离性

数据库上有多个事务同时执行时存在的问题, 以及原因:

> **脏读**就是指当一个事务正在访问数据,并且对数据进行了修改,而这种修改还没有提交到数据库中,这时,另外一个事务也访问这个数
据,然后使用了这个数据. (同时进行的两个事务之间数据是可见的)

> **不可重复读**是指在一个事务内,多次读同一数据. 在这个事务还没有结束时,另外一个事务也访问该同一数据. 那么,在第一个事务
中的两次读数据之间,由于第二个事务的修改(修改,删除和插入),那么第一个事务两次读到的的数据可能是不一样的. 这样在一个事务内两
次读到的数据是不一样的,因此称为是不可重复读. (提交了更改事务对另外一个事务前后数据不一致)

> **幻读**是指当事务不是独立执行时发生的一种现象,例如第一个事务对一个表中的数据进行了修改,这种修改涉及到表中的全部数据行,
同时,第二个事务也修改这个表中的数据,这种修改是向表中插入一行新数据. 那么,以后就会发生操作第一个事务的用户发现表中还有没有
修改的数据行,就好象发生了幻觉一样. (全部数据的修改, 一条数据的修改)的问题


- 脏读(dirty read): 
当一个事务正在访问数据并且对数据进行了修改, 而这种修改还没有提交到数据库中, 这时另外一个事务也访问了这个数据, 然后使用了
这个数据. 因为这个数据是还没有提交的数据, 那么另外一个事务读到的这个数据是"脏数据", 依据"脏数据"所做的操作可能是不正确的. 


- 不可重复读(unrepeatableread): 
指在一个事务内多次读同一数据. 在这个事务还没有结束时, 另一个事务也访问该数据. 那么, 在第一个事务中的两次读数据之间, 由于
第二个事务的修改导致第一个事务两次读取的数据可能不太一样. 这就发生了在一个事务内两次读到的数据是不一样的情况, 因此称为不可
重复读. 

- 幻读(phantom read): 幻读与不可重复读类似. 它发生在一个事务(T1)读取了几行数据, 接着另一个并发事务(T2)插入了一些数据
时. 在随后的查询中, 第一个事务(T1)就会发现多了一些原本不存在的记录, 就好像发生了幻觉一样, 所以称为幻读. 


不可重复度和幻读区别:

不可重复读的重点是修改, 幻读的重点在于新增或者删除.

例1, (同样的条件, 你读取过的数据, 再次读取出来发现值不一样了): 事务1中的A先生读取自己的工资为1000的操作还没完成, 事务2
中的B先生就修改了A的工资为2000, 导致A再读自己的工资时工资变为 2000; 这就是不可重复读.

例2, (同样的条件, 第1次和第2次读出来的记录数不一样): 假某工资单表中工资大于3000的有4人, 事务1读取了所有工资大于3000的
人, 共查到4条记录, 这时事务2又插入了一条工资大于3000的记录, 事务1再次读取时查到的记录就变为了5条, 这样就导致了幻读.

事务隔离级别:

1) READ UNCOMMITTED (读未提交), 没有解决任何问题(脏读,不可重复读,幻读)
2) READ COMMITTED  (读已提交), 解决了脏读.
3) REPEATABLE READ (可重复读), 解决了脏读, 不可重复读. (在Innodb当中也解决了幻读的问题)
4) SERIALIZABLE (可序列化), 解决了脏读, 不可重复读, 幻读

### 事务的持久性


 
 

