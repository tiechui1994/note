### MYSQL的事务级别

问题:

> **脏读**就是指当一个事务正在访问数据,并且对数据进行了修改,而这种修改还没有提交到数据库中,这时,另外一个事务也访问这个
数据,然后使用了这个数据. (同时进行的两个事务之间数据是可见的)

> **不可重复读**是指在一个事务内,多次读同一数据. 在这个事务还没有结束时,另外一个事务也访问该同一数据. 那么,在第一个事
务中的两次读数据之间,由于第二个事务的修改(修改,删除和插入),那么第一个事务两次读到的的数据可能是不一样的. 这样在一个事务
内两次读到的数据是不一样的,因此称为是不可重复读. (提交了更改事务对另外一个事务前后数据不一致)

> **幻读**是指当事务不是独立执行时发生的一种现象,例如第一个事务对一个表中的数据进行了修改,这种修改涉及到表中的全部数据
行,同时,第二个事务也修改这个表中的数据,这种修改是向表中插入一行新数据. 那么,以后就会发生操作第一个事务的用户发现表中还
有没有修改的数据行,就好象发生了幻觉一样. (全部数据的修改, 一条数据的修改)的问题


---


- READ UNCOMMITTED (读未提交), 没有解决任何问题(脏读,不可重复读,幻读)
  
- READ COMMITTED  (读已提交), 解决了脏读.

- REPEATABLE READ (可重复读), 解决了脏读, 不可重复读. (在Innodb当中也解决了幻读的问题)

- SERIALIZABLE (可序列化), 解决了脏读, 不可重复读, 幻读


---


- 脏读*(*Dirty read): 
当一个事务正在访问数据并且对数据进行了修改, 而这种修改还没有提交到数据库中, 这时另外一个事务也访问了这个数据, 
然后使用了这个数据. 因为这个数据是还没有提交的数据, 那么另外一个事务读到的这个数据是"脏数据", 依据"脏数据"所
做的操作可能是不正确的. 


- 丢失修改(Lost to modify): 
指在一个事务读取一个数据时, 另外一个事务也访问了该数据, 那么在第一个事务中修改了这个数据后, 第二个事务也修改了
这个数据. 这样第一个事务内的修改结果就被丢失, 因此称为丢失修改.  
例如: 事务1读取某表中的数据A=20, 事务2也读取A=20, 事务1修改A=A-1, 事务2也修改A=A-1, 最终结果A=19, 事务1
的修改被丢失. 


- 不可重复读(Unrepeatableread): 
指在一个事务内多次读同一数据. 在这个事务还没有结束时, 另一个事务也访问该数据. 那么, 在第一个事务中的两次读数据
之间, 由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样. 这就发生了在一个事务内两次读到的数据是不一
样的情况, 因此称为不可重复读. 

- 幻读(Phantom read): 幻读与不可重复读类似. 它发生在一个事务(T1)读取了几行数据, 接着另一个并发事务(T2)插入
了一些数据时. 在随后的查询中, 第一个事务(T1)就会发现多了一些原本不存在的记录, 就好像发生了幻觉一样, 所以称为幻
读. 


> **不可重复度和幻读区别:**

不可重复读的重点是修改, 幻读的重点在于新增或者删除.

例1, (同样的条件, 你读取过的数据, 再次读取出来发现值不一样了): 事务1中的A先生读取自己的工资为1000的操作还没完
成, 事务2中的B先生就修改了A的工资为2000, 导致A再读自己的工资时工资变为 2000; 这就是不可重复读.

例2, (同样的条件, 第1次和第2次读出来的记录数不一样): 假某工资单表中工资大于3000的有4人, 事务1读取了所有工资大
于3000的人, 共查到4条记录, 这时事务2又插入了一条工资大于3000的记录, 事务1再次读取时查到的记录就变为了5条, 这
样就导致了幻读.