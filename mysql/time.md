# mysql 时间类型解析

MySQL 表示时间值的日期和时间类型是`DATE`, `TIME`, `DATETIME`, `TIMESTAMP` 和 `YEAR`. 每个时间类型
都有一系列有效值, 以及当遇到了 MySQL *无法表示的无效值* 时可以使用的"零"值. `TIMESTAMP` 类型具有特殊的自
动更新行为, 稍后将对此进行描述.

## 使用日期和时间类型时, 一般注意事项

- 尽管MySQL试图以多种格式解释数值, 但日期部分必须始终以 *年-月-日* 的顺序(例如,'98-09-04') 给出, 而不是
以 *月-日-年* 或 *日-月-年*.

- 包含两位数年份值的日期不明确, 因为这个世纪是未知的. MySQL使用以下规则解释两位数的年份值:

>70-99范围内的年份值转换为1970-1999. \
>00-69范围内的年份值将转换为2000-2069.

- 如果在数值环境下使用日期类型值, MySQL会自动将 `Date` 或 `Time` 转换成数字. 反之亦然.

- 默认情况下, 当MySQL遇到 *超出范围的日期或时间类型的值* 或者 *对于该类型无效的值*, 它会将该值转换为该类型
的"零"值. **例外情况是超出范围的 TIME 值被剪切到 TIME 范围的适当端点**.

- 通过将SQL模式设置为适当的值, 可以更准确地指定希望MySQL支持的日期类型. 通过启用 `ALLOW_INVALID_DATES`
SQL模式, 可以让MySQL接受某些日期, 例如 `2009-11-31`. 当希望存储用户在数据库中指定的"可能错误"值(例如, 在
Web表单中)以供将来处理时, 这非常有用. 在此模式下, MySQL *仅验证月份是否在1到12的范围内, 并且该日期的范围是
1到31*.
 
- MySQL 允许在 `DATE` 或 `DATETIME` 列中存储日期或月份和日期为零的日期类型值. 这对于需要存储可能不知道确
切日期的生日的应用程序非常有用.  在这种情况下, 只需将日期存储为 `2009-00-00` 或 `2009-01-00`. 如果存储诸
如此类的日期, 则不能通过使用 `DATE_SUB()` 或 `DATE_ADD()` 等函数去获得需要完整日期的的正确结果.要禁止日期
中零月或零日时, 请启用 `NO_ZERO_IN_DATE` 模式.

- MySQL允许将 `0000-00-00` 的 "零" 值存储为 "dummy date", 这在某些情况下比使用 `NULL` 值更方便, 并且
使用更少的数据和索引空间. 要禁止 `0000-00-00`, 请启用 `NO_ZERO_DATE` 模式.

- 通过 `Connector / ODBC` 使用的 "零" 日期或时间值会自动转换为 `NULL`, 因为 `ODBC` 无法处理此类值.

下表显示了每种类型的 "零" 值的格式. "零" 值是特殊的, 但可以使用表中显示的值显式地存储或引用它们. 也可以使用值
"0" 或 0 来执行此操作, 这样更容易编写. 对于包含日期部分(`DATE`, `DATETIME` 和 `TIMESTAMP`) 的临时类型, 
如果启用了 `NO_ZERO_DATE` SQL模式, 则使用这些值会产生警告.

| TYPE | "Zero" Value |
| --- | --- |
| DATE | '0000-00-00' |
| TIME | '00:00:00' |
| DATETIME | '0000-00-00 00:00:00 |
| TIMESTAMP | '0000-00-00 00:00:00 |
| YEAR | 0000 |


## DATE, DATETIME, TIMESTAMP 类型

### 类型范围 

`DATE`, `DATETIME` 和 `TIMESTAMP` 类型是相关的.

**DATE** 类型用于 *具有日期部分, 但没有时间部分的值*. MySQL 以 `YYYY-MM-DD` 格式检索并显示DATE值. 支持的范
围是 `1000-01-01` 到 `9999-12-31`.

**DATETIME** 类型用于 *包含日期和时间部分的值*. MySQL 以 `YYYY-MM-DD hh:mm:ss` 格式检索并显示 `DATETIME`
值. 支持的范围是 `1000-01-01 00:00:00` 到 `9999-12-31 23:59:59`.

**TIMESTAMP** 类型用于 *包含日期和时间部分的值*. TIMESTAMP 的范围为 `1970-01-01 00:00:01 UTC` 到 
`2038-01-19 03:14:07 UTC`.

无效的 `DATE`, `DATETIME` 或 `TIMESTAMP` 值将转换为相应类型的 "零" 值(`0000-00-00` 或 `0000-00-00 00:00:00`).


### DATETIME 或 TIMESTAMP 的相同点

`DATETIME` 或 `TIMESTAMP` 值可以包括高达 *微秒* (6位)精度的尾随小数秒部分. 特别地, 插入 `DATETIME` 或 
`TIMESTAMP` 列的值中的任何小数部分都将被存储而不是被丢弃. 包含小数部分, 这些值的格式为 `YYYY-MM-DD hh:mm:ss[.us]`,
`DATETIME` 值的范围为 `1000-01-01 00:00:00.000000` 到 `9999 -12-31 23:59:59.999999`, `TIMESTAMP`
值的范围是 `1970-01-01 00:00:01.000000` 到 `2038-01-19 03:14:07.999999`. 小数部分应始终与其余时间分开
一个小数点; 不能识别出其他小数秒分隔符.

`DATETIME` 和 `TIMESTAMP` 数据类型提供自动初始化和更新到当前日期和时间.


### TIMESTAMP 特点:

MySQL 将 `TIMESTAMP` 值从当前时区转换为 `UTC` 以进行存储, 并从 `UTC` 转换回当前时区以进行检索. (对于其他类
型, 例如 `DATETIME`, 不会发生这种情况.) 默认情况下, 每个连接的当前时区是服务器的时间. 可以基于每个连接设置时区. 
只要时区设置保持不变, 就会获得存储的相同值. 如果存储 `TIMESTAMP` 值, 然后更改时区并检索该值, 则检索的值与您存储
的值不同. 发生这种情况是因为在两个方向上都没有使用相同的时区进行转换. 当前时区可用作 `time_zone` 系统变量的值.


### **注意MySQL中日期值解释的某些属性.**

- 1.MySQL允许对指定为字符串的值使用 "relaxed(宽松)" 格式, 其中任何标点符号都可以用作日期部分或时间部分之间的分
隔符. 在某些情况下, 这种语法可能是欺骗性的. 例如, `10:11:12` 之类的值可能看起来像时间值, 因为使用了 `:`, 但如
果在日期上下文中使用, 则会被解释为年份 `2010-11-12`. 值 `10:45:15` 被转换为 `0000-00-00`, 因为 `45` 不是
有效月份.

在日期和时间部分与小数秒部分之间识别的唯一分隔符是小数点.

- 2.服务器要求月和日值有效, 而不仅仅分别在1到12和1到31的范围内. 禁用严格模式后, `2004-04-31` 等无效日期将转换
为 `0000-00-00`, 并生成警告. 启用严格模式后, 无效日期会生成错误. 要允许此类日期, 启用sql模式`ALLOW_INVALID_DATES`.

- 3.MySQL 不接受在日期或月份列中包含零的 `TIMESTAMP` 值或不是有效日期的值. 该规则的唯一例外是特殊的 "零" 值
`0000-00-00 00:00:00`.

- 4.可以在启用 `MAXDB` SQL模式的情况下运行MySQL服务器. 在这种情况下, `TIMESTAMP` 与 `DATETIME` 相同. 如果在
创建表时启用此模式, 则会将 `TIMESTAMP` 列创建为 `DATETIME` 列. 因此, 此类列使用 `DATETIME` 显示格式, 具有相
同的值范围, 并且**没有自动初始化或更新到当前日期和时间**.

> MySQL 5.7.22 之后, MAXDB 模式就弃用了.


## TIEM 类型

MySQL 以 `hh:mm:ss` 格式(或 `hhh:mm:ss` 格式) 检索并显示 `TIME` 值. `TIME` 值的范围可以从 `-838:59:59`
到 `838:59:59`.  小时部分可能非常大, 因为 `TIME` 类型不仅可以用来表示一天中的时间(必须小于24小时), 还可以用于
表示两个事件之间的经过时间或时间间隔 (可能远大于24小时, 甚至是负数).

MySQL以多种格式识别 `TIME` 值, 其中一些格式可包括精确到 *微秒*(6位) 的尾随小数秒部分. 存储而不是丢弃插入到 `TIME`
列中的值中的任何小数部分. 包含小数部分, `TIME` 值的范围是 `-838:59:59.000000` 到 `838:59:59.000000`.


将缩写值分配给 `TIME` 列时要小心. MySQL用冒号解释缩写的 `TIME` 值作为一天中的时间. 也就是说, `11:12` 表示的是 
`11:12:00`, 而不是 `00:11:12`. MySQL使用假设最右边的两个数字代表秒数 (即经过时间而不是时间) 来解释没有冒号的缩
写值. 例如, 可能会将 `'1112'` 和 `1112` 视为 `11:12:00` (11点后12分钟), 但MySQL将其解释为 `00:11:12` (11
分12秒). 类似地, `'12'`和 `12` 被解释为 `00:00:12`.

在时间部分和小数秒部分之间识别的唯一分隔符是小数点.


默认情况下, 位于 `TIME` 范围之外但其他方式有效的值将剪切到范围的最近端点. 例如, `-850:00:00` 和 `850:00:00` 
被转换为 `-838:59:59` 和 `838:59:59`. 无效的 `TIME` 值将转换为 `00:00:00`. 注意, 因为 `00：00：00` 本
身是一个有效的 `TIME` 值, 所以无法从表中存储的 `00:00:00` 值中判断原始值是否指定为 `00:00:00` 或是否无效.

要对无效 `TIME` 值进行更严格的处理, 请启用严格SQL模式以导致错误发生.

