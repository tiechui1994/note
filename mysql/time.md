# mysql 时间类型解析

MySQL 表示时间值的日期和时间类型是`DATE`, `TIME`, `DATETIME`, `TIMESTAMP` 和 `YEAR`. 每个时间类型
都有一系列有效值, 以及当遇到了 MySQL `无法表示的无效值` 时可以使用的"零"值. `TIMESTAMP` 类型具有特殊的自
动更新行为, 稍后将对此进行描述.

## 使用日期和时间类型时, 一般注意事项

- 尽管MySQL试图以多种格式解释数值, 但日期部分必须始终以 `年-月-日` 的顺序(例如,'98-09-04') 给出, 而不是
以 `月-日-年` 或 `日-月-年`.

- 包含两位数年份值的日期不明确, 因为这个世纪是未知的. MySQL使用以下规则解释两位数的年份值: \
```
70-99范围内的年份值转换为1970-1999.

00-69范围内的年份值将转换为2000-2069.
```

- 如果在数值环境下使用日期类型值, MySQL会自动将 `Date` 或 `Time` 转换成数字. 反之亦然.

- 默认情况下, 当MySQL遇到 `超出范围的日期或时间类型的值` 或者 `对于该类型无效的值`, 它会将该值转换为该类型
的"零"值. **例外情况是超出范围的 TIME 值被剪切到 TIME 范围的适当端点**.

- 通过将SQL模式设置为适当的值, 可以更准确地指定希望MySQL支持的日期类型. 通过启用 `ALLOW_INVALID_DATES`
SQL模式, 可以让MySQL接受某些日期, 例如 `2009-11-31`. 当希望存储用户在数据库中指定的"可能错误"值(例如, 在
Web表单中)以供将来处理时, 这非常有用. 在此模式下, MySQL `仅验证月份是否在1到12的范围内, 并且该日期的范围是
1到31`.
 
- MySQL 允许在 `DATE` 或 `DATETIME` 列中存储 `日期或月份` 和 `日期` 为零的日期类型值. 这对于需要存储可
能不知道确切日期的生日的应用程序非常有用.  在这种情况下, 只需将日期存储为 `2009-00-00` 或 `2009-01-00`. 
如果存储诸如此类的日期, 则不能通过使用 `DATE_SUB()` 或 `DATE_ADD()` 等函数去获得需要完整日期的的正确结果.
要禁止日期中 `零月` 或 `零日` 时, 请启用 `NO_ZERO_IN_DATE` 模式.

- MySQL允许将 `0000-00-00` 的 "零" 值存储为 "dummy date", 这在某些情况下比使用 `NULL` 值更方便, 并且
使用更少的数据和索引空间. 要禁止 `0000-00-00`, 请启用 `NO_ZERO_DATE` 模式.

- 通过 `Connector / ODBC` 使用的 "零" 日期或时间值会自动转换为 `NULL`, 因为 `ODBC` 无法处理此类值.

下表显示了每种类型的 "零" 值的格式. "零" 值是特殊的, 但可以使用表中显示的值显式地存储或引用它们. 也可以使用值
"0" 或 0 来执行此操作, 这样更容易编写. 对于包含日期部分(`DATE`, `DATETIME` 和 `TIMESTAMP`) 的临时类型, 
如果启用了 `NO_ZERO_DATE` SQL模式, 则使用这些值会产生警告.

| TYPE | "Zero" Value |
| --- | --- |
| DATE | '0000-00-00' |
| TIME | '00:00:00' |
| DATETIME | '0000-00-00 00:00:00 |
| TIMESTAMP | '0000-00-00 00:00:00 |
| YEAR | 0000 |


## DATE, DATETIME, TIMESTAMP 类型

### 类型范围 

`DATE`, `DATETIME` 和 `TIMESTAMP` 类型是相关的.

**DATE** 类型用于 `具有日期部分` 但 `没有时间部分` 的值. MySQL 以 `YYYY-MM-DD` 格式检索并显示DATE值. 支持的
范围是 '1000-01-01' 到 '9999-12-31'.

**DATETIME** 类型用于 `包含日期和时间部分` 的值. MySQL 以 `YYYY-MM-DD hh:mm:ss` 格式检索并显示DATETIME值. 
支持的范围是 `1000-01-01 00:00:00` 到 `9999-12-31 23:59:59`.

**TIMESTAMP** 类型用于 `包含日期和时间部分` 的值. TIMESTAMP 的范围为 `1970-01-01 00:00:01 UTC` 到 
`2038-01-19 03:14:07 UTC`.

无效的 `DATE`, `DATETIME` 或 `TIMESTAMP` 值将转换为相应类型的 "零" 值(`0000-00-00` 或 `0000-00-00 00:00:00`).


### DATETIME 或 TIMESTAMP 的相同点

`DATETIME` 或 `TIMESTAMP` 值可以包括高达 `微秒` (6位)精度的尾随小数秒部分. 特别地, 插入 `DATETIME` 或 
`TIMESTAMP` 列的值中的任何小数部分都将被存储而不是被丢弃. 包含小数部分, 这些值的格式为 `YYYY-MM-DD hh:mm:ss[.us]`,
`DATETIME` 值的范围为 `1000-01-01 00:00:00.000000` 到 `9999 -12-31 23:59:59.999999`, `TIMESTAMP`
值的范围是 `1970-01-01 00:00:01.000000` 到 `2038-01-19 03:14:07.999999`. 小数部分应始终与其余时间分开
一个小数点; 不能识别出其他小数秒分隔符.

`DATETIME` 和 `TIMESTAMP` 数据类型提供自动初始化和更新到当前日期和时间.


### TIMESTAMP 特点:

MySQL 将 `TIMESTAMP` 值从当前时区转换为 `UTC` 以进行存储, 并从 `UTC` 转换回当前时区以进行检索. (对于其他类
型, 例如 `DATETIME`, 不会发生这种情况.) 默认情况下, 每个连接的当前时区是服务器的时间. 可以基于每个连接设置时区. 
只要时区设置保持不变, 就会获得存储的相同值. 如果存储 `TIMESTAMP` 值, 然后更改时区并检索该值, 则检索的值与您存储
的值不同. 发生这种情况是因为在两个方向上都没有使用相同的时区进行转换. 当前时区可用作 `time_zone` 系统变量的值.


### **注意MySQL中日期值解释的某些属性.**

- 1.MySQL允许对指定为字符串的值使用 "relaxed(宽松)" 格式, 其中任何标点符号都可以用作日期部分或时间部分之间的分隔符. 
在某些情况下, 这种语法可能是欺骗性的. 例如, `10:11:12` 之类的值可能看起来像时间值, 因为使用了 `:`, 但如果在日期上
下文中使用, 则会被解释为年份 `2010-11-12`. 值 `10:45:15` 被转换为 `0000-00-00`, 因为 `45` 不是有效月份.

在日期和时间部分与小数秒部分之间识别的唯一分隔符是小数点.

- 2.服务器要求 `月` 和 `日` 值有效, 而不仅仅分别在 `1到12` 和 `1到31` 的范围内. 禁用严格模式后, `2004-04-31` 
等无效日期将转换为 `0000-00-00`, 并生成警告. 启用严格模式后, 无效日期会生成错误. 要允许此类日期, 启用sql模式
`ALLOW_INVALID_DATES`.

- 3.MySQL 不接受在 `日期` 或 `月份` 列中包含零的 `TIMESTAMP` 值或不是有效日期的值. 该规则的唯一例外是特殊的 
"零" 值 `0000-00-00 00:00:00`.

- 4.可以在启用 `MAXDB` SQL模式的情况下运行MySQL服务器. 在这种情况下, `TIMESTAMP`与 `DATETIME` 相同. 如果在创建
表时启用此模式, 则会将 `TIMESTAMP` 列创建为 `DATETIME` 列. 因此, 此类列使用 `DATETIME` 显示格式, 具有相同的值
范围, 并且**没有自动初始化或更新到当前日期和时间**.

> MySQL 5.7.22 之后, MAXDB 模式就弃用了.


## TIEM 类型
