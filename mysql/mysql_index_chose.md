## MySQL 专题 - 索引类型选择

InnoDB 索引组织结构

![image](/images/mysql_index.png)

关于普通索引和唯一索引, 对查询语句和更新语句的性能影响分析.

### 查询语句

假设, 执行查询的语句是 'select id from T where k=5'. 该查询语句在索引树上查找的过程, 先是通过 B+ 树从根开始, 按层
搜索到叶子阶段, 也就是图中右下角的这个数据页, 然后可以认为数据页内部通过二分法来定位记录.

- 对于普通索引, 查到满足条件的第一个记录(5,500)后, 需要查找下一个记录, 直到碰到第一个不满足k=5条件的记录.

- 对于唯一索引, 由于索引的唯一性, 查找到第一个满足条件的记录后, 会立即停止继续检索.

这个不同带来的性能差距是微乎其微的.

InnoDB 的数据是按照页为单位来读写的. 也就是说, 当需要读一条记录的时候, 并不是将这个记录本身从磁盘上读出来, 而是以页为单
位, 将其整体读入内存. InnoDB, 默认情况下, 页大小是 16KB.

因为 InnoDB 是按页读写的, 当找到 k=5 的记录时, 它所在的数据页都在内存里了. 那么对于普通索引来说, 要多做的那一次"查找和
判断下一条记录"的操作, 就只需要一次指针寻找和一次计算. 

当然, 如果 k=5 这条记录刚好是这个数据页的最后一条记录, 那么要取下一个数据页, 这个操作会稍微复杂一些.


### 更新语句

change buffer:

当需要更新一个数据页时, 如果数据页在内存中就直接更新, 而如果这个数据页还没有在内存中, 在不影响数据一致性的前提下, InnoDB
会将这些更改操作缓存在 change buffer 中, 这样就不需要从磁盘中读入这个数据页了. 在下次查询需要访问这个数据页的时候, 将数
据页读入内存, 然后执行 change buffer 中与这个页有关的操作. 通过这种方式就能保证这个数据逻辑的正确性.

> change buffer, 实际上它是可以持久化的数据. 即, change buffer 在内存中有拷贝, 也会被写入到磁盘上.

将change buffer 中的操作应用到原始数据页, 得到最新结果的过程称为merge. 除了访问这个数据页会触发merge外, 系统有后台线
程会定期 merge. 在数据库正常关闭时, 也会执行 merge 操作.

什么条件下使用 change buffer ?

对于唯一索引, 所有的更新操作都要先判断这个操作是否违反唯一性约束. 例如, 要插入(4,400)记录, 就要先判断表中是否已经存在了
k=4的记录, 那必须要将数据页读入内存才判断. 如果都已经读入到内存了, 那直接更新内存会更快, 就没必要使用 change buffer了.

因此, 唯一索引更新就不能使用 change buffer. 实际上只有普通索引才可以使用 change buffer.

change buffer使用的是buffer pool的内存, 内存不能无线增大. change buffer的大小可以通过 innodb_change_buffer_max_size
来动态调整. 最大值是50, 表示change buffer最多能占用buffer pool的50%

如果要在表中插入一条新的记录 (4,400), InnoDB 的处理流程是:

第一种情况, 这个记录要更新的目标页在内存中. 

- 对于唯一索引, 找到3和5之间的位置, 判断到没有冲突, 插入这个值, 语句执行结束.
- 对于普通索引, 找到3和5之间的位置, 插入这个值, 语句执行结束.

这种情况下, 普通索引和唯一索引对更新语句性能影响的差别微乎其微.

第二种情况, 这个记录要更新的目标页不在内存中.

- 对于唯一索引, 需要将数据页读入内存, 判断到没有冲突, 插入这个值, 语句执行结束.
- 对于普通索引, 则是将更新记录到change buffer, 语句执行结束.

将数据从磁盘读入内存涉及到随机IO访问, 是数据库里成本最高的操作之一. change buffer吟哦减少了随机磁盘访问, 所以对更新的
性能提升是很明显的.

change buffer 使用场景:

通过上面分析, 清楚了 change buffer 对更新的加速作用, 清楚了 change buffer 只限用在普通索引的场景下. 但是, 普通索引
的所有场景, 使用 change buffer 都可以起到加速作用吗?

因为 merge 的操作是真正进行数据页更新的时刻, 而 change buffer 的主要目的是将记录的变更操作缓存下来了, 所以在一个数据
页做merge之前, change buffer 记录的变更越多(在这个页面上要更新的次数越多), 收益越大.

因此, 对于写多读少的业务, 页面在写完成之后马上访问到的概率很小, 此时change buffer使用效果最好. 比如账单, 日志.

反过来, 如果业务的更新模式是写入之后马上会做查询, 那么即使满足了条件, 将更新记录在chenge buffer, 但之后由于马上要访问
这个数据页, 会立即触发 merge 过程. 这样随机IO的次数不会检查, 反而增加了 change buffer 的代价.


 
