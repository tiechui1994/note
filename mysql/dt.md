# 分布式事务的解决方案

三种方案:

2PC, 3PC(不怎么使用), 以及最终一致性

## 2PC (两阶段提交)

### 角色:

- 参与者: 本地资源管理器(RM), 即事务的执行者, 也就是各个业务系统.

- 协调者: 分布式事务的大脑(TC), 负责指挥协调各个业务系统提交/回滚事务.

### 协议内容:

- 第一阶段(投票阶段, voting)

协调者将记录 `<prepare T>` 加入到日志当中, 并强制日志写入稳定存储器上. 接着它将一条 `prepare T` 消息发送到执行 `T` 
的所有的参与者. 当参与者收到消息时, 参与者的事务管理器确定是否愿意提交 `T` 中属于它的那部分. 如果是 "NO", 事务管理器把
记录 `<no T>` 加入到日志中, 然后向协调者发送 `abort T` 消息作为响应. 如果是 "YES", 事务管理器就把记录 `<ready T>` 
加入到日志中, 并将日志(包括所有与T相关的日志记录)强制写入稳定存储器上. 然后事务管理器向协调者回复一条 `ready T`消息作为
回答.


- 第二阶段(执行提交阶段, commit)

当协调者收到所有参与者对 `prepare T` 消息的回答时, 或者自 `prepare T` 消息发送后经过一个预定是时间间隔时, 协调者就
可以确定是将事务T提交还是终止. 如果协调者接收到来自所有事务参与者的 `ready T` 消息, 那么事务T可以提交. 否则事务T必须终
止. 根据结论, 要么将记录 `<commit T>`,要么将记录 `<abort T>` 加入到日志当中, 并将日志强制写入稳定存储器上. 这时,事
务最终结果就已经确定了. 此后, 协调者向所有参与者发送消息 `commit T` 或 `abort T`. 当参与者收到此消息后, 它就把记录
`<commit T>` 或 `<abort T>` 加入到日志中. 然后执行 `commit` 或 `rollback` 操作, 释放相关的资源. 


> 额外实现:

操作完成以后, 向协调者发送 `ack T` 消息. 当协调者收到所有参与者发来的 `ack T` 消息后, 它就把记录  `<complete T>`
加入到日志当中.


在向协调者发送 `ready T` 消息之前, 执行T的参与者可以在任何时候无条件地终止T. 一旦发出 `ready T`消息, 参与者的事务就
称为**就绪状态(ready state)**. 在效果上, `ready T`消息是站点所做的承诺: 即按照协调器的命令来提交T或者终止T. 为了做
出这样的承诺, 所需信息必须首先存储在稳定存储器中. 否则, 如果参与者发送 `ready T` 之后崩溃, 它可能就不能兑现自己的承诺. 
进而言之, 事务拥有的锁必须继续保留直到事务结束.


### 故障处理:

- 参与者故障: 

如果协调器检测到某个参与者发生故障, 它将采取如下措施:

1) 如果参与者在使用 `ready T` 消息回复协调者前发生故障, 那协调者假定该节点是用 `abort T`消息来回答的.
2) 如果参与者在协调者接收到从该参与者发生发出的 `ready T` 消息后发生故障, 则协调者就按照通常的方式执行协议的剩余部分, 
忽略该参与者的故障.

当参与者S从故障中恢复时, 它必须检查它的日志来决定故障发生时正在执行中的事务的最终结果. 

a)日志包含 `<commit T>` 记录. 这种情况下, S执行 `redo(T)`.

b)日志包含 `<abort T>` 记录. 这种情况下, S执行 `undo(T)`.

c)日志包含 `<ready T>` 记录. 在这种情况下, 参与者S必须询问协调者以决定T的最终结果. 

```
如果协调者正在工作, 它就通知S关于T是否提交或者终止的信息. 在前一种情况下, S执行 redo(T); 在后一种情况下, S执行 undo(T).

如果协调者出现故障, S就必须试图从其他参与者找到T的最终结果. 它通过向系统中所有站点发送 `querystatus T`
消息来进行这一操作. 参与者收到这样一条消息, 就必须查阅其日志来判断T是否在该站点上执行过, 如果是, 还要看T
是否提交或终止. 接着把结果告知S. 如果没有站点提供恰当的消息(即T是否提交或终止), 那么S既不能终止T, 也不能
提交T. 关于T的决定被推迟到S能得到所需信息时为止. 因此S必须定时向其他参与者发送 `querystatus T` 消息.
```

d)日志没有包含关于T的控制记录(`abort`, `commit`, `ready`). 因此, 我们知道 S 在响应来自协调者 `prepare T`
消息之前发生了故障. 由于S的故障排除了发送这样一个响应的可能性. 根据协议, S必须执行 `undo(T)`

- 协调者故障:

如果协调者在事务T执行提交协议的过程中发生故障, 那必须由参与事务T的那些参与者来决定事务T的最终结果. 我们会看到,
在特定情况下, 参与者不能决定是否提交或者终止T,  因此这些参与者必须等待发生故障的协调者恢复.

1)如果活跃的参与者在其日志当中包含 `<commit T>` 记录, 则 T 必须提交.

2)如果活跃的参与者在其日志当中包含 `<abort T>` 记录, 则 T 必须终止.

3)如果某些参与者在其日志当中没有包含 `<ready T>` 记录, 则发生故障的协调者不可能已经决定将 T 提交, 因为在其
日志当中没有 `<ready T>` 记录的参与者不会已经向协调者发送 `ready T` 消息. 但是协调者可能已经决定终止T而不
是提交T. 与等协调者恢复相比, 终止T更为可取.

4)如果上述情况均不成立, 则所有活跃的参与者在它们的日志中都有 `<ready T>` 记录, 但没有别的控制记录(如 `<abort T>`
或 `<commit T>`). 由于协调者已经发生故障, 因此不等到协调器恢复, 就不可能确定是否已经做出决定. 因此, 活跃的
参与者必须等协调者恢复. 由于 T 的最终结果还是一个疑问, 因此 T 可能继续占用系统资源. 例如, 如果使用锁, T可能拥
有活跃参与者上数据的锁.


- 网络划分:

1)协调者与它所有参与者处于一个分区当中. 这种情况下, 故障对提交协议没有影响.

2)协调者与它的参与者属于几个分区.

### 2PC的不足:

1.同步阻塞问题: 2PC 在执行过程中, 所有参与节点都是事务阻塞型, 参与者会锁定数据, 其他访问者要访问该数据的
话, 都会被阻塞.

2.单点故障问题: 协调者只有一台, 一旦协调者发生故障, 整个系统都会处于停滞阶段. 特别是提交阶段, 如果协调者
挂了的话, 参与者就会一直等待协调者回应, 会处于阻塞中.

3.数据不一致问题: 在提交阶段, 协调者向参与者发送 DoCommit 请求后, 由于网络抖动或者在发送请求的过程中, 协
调者发生故障, 就会导致只有一部分参与者接收到了提交请求并执行提交操作, 但其他未接到提交请求的那部分参与者则无
法执行事务提交. 于是整个分布式系统便出现了数据不一致的问题.

## 最终一致性协议

## 2PC 的实现

- XA
- TCC
- AT

