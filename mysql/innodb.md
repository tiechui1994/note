# InnoDB

InnoDB 架构模型:

![image](/images/mysql_innodb_architecture.png)

## Mutil-Version

InnoDB 是一个 Mutil-Version 存储引擎. 保存了修改 row 的旧版本的信息, 以支持事务的并发和回滚功能. 这些信息以 `rollback
segment` 的数据结构存储在 system tablespace 或 undo tablespace 当中. InnoDB 使用 `rollback segment` 当中的
信息来执行事务的回滚所需撤销的操作, 或为 `consistent read` 构建 row 的早期版本.

InnoDB 会为存储在数据库当中的 row 添加3个字段:

- DB_TRX_ID, 长度是 6byte, 表示插入或更新 row 的最后一个事务标识符. '删除' 在 InnoDB 内部当中被视为更新, row 设置
特殊的标记位表示已删除.

- DB_ROLL_PTR, 长度是 7byte, 表示回滚指针. 回滚指针指向写入 `rollback segment` 的 undo log 记录. 如果 row 被
更新, undo log 记录包含在更新重建该行内容所需的信息.(可以构建更新前的行)

- DB_ROW_ID, 长度是 6byte, 表示 row ID, 随着插入新行而单调增加. 如果 InnoDB 自动生成聚簇索引, 则聚簇索引包含 row ID
的值. 否则, DB_ROW_ID 列不会出现任何索引当中.

`rollback segment` 中的 Undo Log 分为插入和更新(Undo Log). 插入(Undo Log)仅在事务回滚时需要, 并且可以在事务提
交后立即丢弃. 更新(Undo Log)用于一致性读取, 但只有在 "没有事务存在" 且 "为其InnoDB分配快照(snapshot)的情况" 下才能
丢弃它们, 在一致性读取中可能需要更新(Undo Log)中的信息来构建较早版本的数据行.

> 建议定期提交事务, 包括仅发出一致性读取的事务, 否则, InnoDB 无法从更新(Undo Log)中丢弃数据, 并且 `rollback segment`
可能会变得很大, 填满所在的表空间.

在 InnoDB Mutil-Version中, 当使用 SQL 语句删除某行时, 不会立即从数据库中物理删除该行. InnoDB 只有在丢弃为删除而写
入的更新(Undo Log)时, 才物理删除相应行及其索引记录. 这种删除操作称为清除(purge), 它非常快, 通常与执行删除操作的顺序是
一致的.

如果在表中以大致相同的速度小批量插入和删除行, 清除(purge)线程可能会滞后, 并且由于所有"dead"行, 表会变得越来越大, 从而
使所有内容都受磁盘限制并且很慢. 这种情况下, 同规格调整 `innodb_max_purge_lag` 变量来限制新行操作, 并为清除线程分配
更多资源.

### Mutil-Version 与 Secondary Index

InnoDB MVCC 处理二级索引和聚簇索引不同. 聚簇索引中的记录就地更新, 它们隐藏的系统列指向Undo Log条目, 可以从中重建记录的
早期版本数据. 二级索引不包含隐藏的系统列, 也不会就地更新.

当二级索引列被更新时, old 二级索引记录会被标记为删除, new 记录被插入, 最终被标记为删除的记录被清除(purge). 当二级索引
记录被标记为删除或二级索引页被事务更新时, InnoDB会在聚簇索引查找该数据库记录. 在聚簇索引中, 会检查记录的 DB_TRX_ID, 
如果在读取事务启动后修改了记录, 则从Undo Log当中检索记录的正确版本, 并修正记录的 DB_TRX_ID.

如果二级索引记录被标记为删除或二级索引页被事务所更新, 则不会使用覆盖索引技术. InnoDB 会使用聚簇索引查找记录并返回相应的
值, 而不是直接从二级索引结构当中返回. `回表`

但是, 如果启用了索引条件下推(ICP)优化, 并且 WHERE 可以仅使用索引中的字段评估部分条件, 则 MySQL 仍会将这部分 WHERE 
条件下推到存储引擎, 在那里使用索引评估. 如果没有查找到匹配的记录, 则避免聚簇索引查找. 如果找到匹配的记录, 即使是在被标记
为删除的记录中, 也会在 InnoDB 聚餐索引中查找该记录.

## 事务

### 特性

- 原子性(A)

"原子性"方面涉及到 InnoDB 事务, 相关的 MySQL 功能: `COMMIT` 语句, `ROLLBACK` 语句. 

原子性通过 undo log 实现的.

- 一致性(C)

"一致性"方面主要涉及 InnoDB 内部处理, 以防止数据崩溃. 相关 MySQL 功能: InnoDB `doublewrite buffer`, 
InnoDB `crash recovery`.

一致性是通过原子性, 持久性, 隔离性实现的. 这是数据库的终极目标.

- 隔离性(I)

"隔离性"方面涉及到 InnoDB 事务, 尤其是适合于每个事务的隔离级别. 相关 MySQL 功能: `事务隔离级别设置`, `InnoDB 锁`

隔离性是通过读写锁+MVCC实现的.

- 持久性(D)

相关的 MySQL 功能:

1) InnoDB `doublewrite buffer`
2) `innodb_flush_log_at_trx_commit`,  `sync_binlog`, `innodb_file_per_table` 变量
3) 存储设备的写缓存区.
4) 用于运行 MySQL 的 OS, 特别是对 `fsync()` 系统调用的支持.
5) 备份策略
6) MySQL 集群, 以及集群之间的网络.

持久性是通过 redo log 来实现的.

### redo_log, undo_log, mvcc

redo log(重做日志), 是用来实现事务的持久性. 该日志文件分为两部分: 重做日志缓冲(redo log buffer)以及重做日志(redo log).

redo log 作用:

1. 恢复数据的保障, 已提交事务的持久化特性.

2. redo log 的顺序写入, 提升数据库的IO性能.

undo log(回滚日志), 用于记录数据的逻辑变化, 为了在发送错误时回滚之前的操作.

undo log 作用:

1. undo log 是用来回滚数据的保障, 保证事务的原子性.


### 事务隔离性

数据库上有多个事务同时执行时存在的问题, 以及原因:

> **脏读**就是指当一个事务正在访问数据,并且对数据进行了修改,而这种修改还没有提交到数据库中,这时,另外一个事务也访问这个数
据,然后使用了这个数据. (同时进行的两个事务之间数据是可见的)

> **不可重复读**是指在一个事务内,多次读同一数据. 在这个事务还没有结束时,另外一个事务也访问该同一数据. 那么,在第一个事务
中的两次读数据之间,由于第二个事务的修改(修改,删除和插入),那么第一个事务两次读到的的数据可能是不一样的. 这样在一个事务内两
次读到的数据是不一样的,因此称为是不可重复读. (提交了更改事务对另外一个事务前后数据不一致)

> **幻读**是指当事务不是独立执行时发生的一种现象,例如第一个事务对一个表中的数据进行了修改,这种修改涉及到表中的全部数据行,
同时,第二个事务也修改这个表中的数据,这种修改是向表中插入一行新数据. 那么,以后就会发生操作第一个事务的用户发现表中还有没有
修改的数据行,就好象发生了幻觉一样. (全部数据的修改, 一条数据的修改)的问题


- 脏读(dirty read): 
当一个事务正在访问数据并且对数据进行了修改, 而这种修改还没有提交到数据库中, 这时另外一个事务也访问了这个数据, 然后使用了
这个数据. 因为这个数据是还没有提交的数据, 那么另外一个事务读到的这个数据是"脏数据", 依据"脏数据"所做的操作可能是不正确的. 


- 不可重复读(unrepeatableread): 
指在一个事务内多次读同一数据. 在这个事务还没有结束时, 另一个事务也访问该数据. 那么, 在第一个事务中的两次读数据之间, 由于
第二个事务的修改导致第一个事务两次读取的数据可能不太一样. 这就发生了在一个事务内两次读到的数据是不一样的情况, 因此称为不可
重复读. 

- 幻读(phantom read): 幻读与不可重复读类似. 它发生在一个事务(T1)读取了几行数据, 接着另一个并发事务(T2)插入了一些数据
时. 在随后的查询中, 第一个事务(T1)就会发现多了一些原本不存在的记录, 就好像发生了幻觉一样, 所以称为幻读. 


不可重复度和幻读区别:

不可重复读的重点是修改, 幻读的重点在于新增或者删除.

例1, (同样的条件, 你读取过的数据, 再次读取出来发现值不一样了): 事务1中的A先生读取自己的工资为1000的操作还没完成, 事务2
中的B先生就修改了A的工资为2000, 导致A再读自己的工资时工资变为 2000; 这就是不可重复读.

例2, (同样的条件, 第1次和第2次读出来的记录数不一样): 假某工资单表中工资大于3000的有4人, 事务1读取了所有工资大于3000的
人, 共查到4条记录, 这时事务2又插入了一条工资大于3000的记录, 事务1再次读取时查到的记录就变为了5条, 这样就导致了幻读.

事务隔离级别:

1) READ UNCOMMITTED (读未提交), 没有解决任何问题(脏读,不可重复读,幻读)
2) READ COMMITTED  (读已提交), 解决了脏读.
3) REPEATABLE READ (可重复读), 解决了脏读, 不可重复读. (在Innodb当中也解决了幻读的问题)
4) SERIALIZABLE (可序列化), 解决了脏读, 不可重复读, 幻读
