# InnoDB 存储引擎

InnoDB 架构模型:

![image](/images/mysql_innodb_architecture.png)

## 多版本

InnoDB 是一个 multi-version 存储引擎. 保存了修改 row 的旧版本的信息, 以支持事务的并发和回滚功能. 这些信息以 `rollback
segment`的数据结构存储在 system tablespace 或 undo tablespace当中. InnoDB 使用 `rollback segment` 当中的信息
来执行事务的回滚所需撤销的操作, 或为 `consistent read` 构建 row 的早期版本.

InnoDB 会为存储在数据库当中的 row 添加3个字段:

- DB_TRX_ID, 长度是 6byte, 表示插入或更新 row 的最后一个事务标识符. '删除' 在 InnoDB 内部当中被视为更新, row 设置
特殊的标记位表示已删除.

- DB_ROLL_PTR, 长度是 7byte, 表示回滚指针. 回滚指针指向写入 `rollback segment` 的 undo log 记录. 如果 row 被
更新, undo log 记录包含在更新重建该行内容所需的信息.(可以构建更新前的行)

- DB_ROW_ID, 长度是 6byte, 表示 row ID, 随着插入新行而单调增加. 如果 InnoDB 自动生成聚簇索引, 则聚簇索引包含 row ID
的值. 否则, DB_ROW_ID 列不会出现任何索引当中.

`rollback segment` 中的 undo log 分为插入和更新(undo log). 插入(undo log) 仅在事务回滚时需要, 并且可以在事务提
交后立即丢弃. 更新(undo log)用于一致性读取, 但只有在 "没有事务存在" 且 "为其InnoDB分配快照(snapshot)的情况" 下才能
丢弃它们, 在一致性读取中可能需要更新(undo log)中的信息来构建较早版本的数据行.

> 建议定期提交事务, 包括仅发出一致性读取的事务, 否则, InnoDB 无法从更新(undo log)中丢弃数据, 并且 `rollback segment`
可能会变得很大, 填满所在的表空间.

在 InnoDB 多版本中, 当使用 SQL 语句删除某行时,不会立即从数据库中物理删除该行. InnoDB 只有在丢弃为删除而写入的更新(undo log)
时, 才物理删除相应行及其索引记录. 这种删除操作称为清除(purge), 它非常快, 通常与执行删除操作的顺序是一致的.

如果在表中以大致相同的速度小批量插入和删除行, 清除(purge)线程可能会滞后, 并且由于所有"dead"行, 表会变得越来越大, 从而
使所有内容都受磁盘限制并且很慢. 这种情况下, 同规格调整 `innodb_max_purge_lag` 变量来限制新行操作, 并为清除线程分配
更多资源.

### 多版本与二级索引

InnoDB MVCC 处理二级索引和聚簇索引不同. 聚簇索引中的记录就地更新, 它们隐藏的系统列指向undo log条目, 可以从中重建记录的
早期版本数据. 二级索引不包含隐藏的系统列, 也不会就地更新.

当二级索引列被更新时, 旧的二级索引记录会被标记为删除, 新的记录被插入, 最终被标记为删除的记录被清除. 当二级索引记录被标记
为删除或二级索引页被事务更新时, InnoDB会在聚集索引查找该数据库记录. 在聚餐索引中, 会检查记录的 DB_TRX_ID, 如果在读取事
务启动后修改了记录, 则从undo log当中检索记录的正确版本. 

如果二级索引记录被标记为删除或二级索引页被事务所更新, 则不会使用覆盖索引技术. InnoDB 会使用聚簇索引查找记录并返回相应的
值, 而不是直接从二级索引结构当中返回. `回表`

但是, 如果启用咯额索引条件下推(ICP)优化, 并且 WHERE 可以仅使用索引中的字段评估部分条件, 则 MySQL 仍会讲这部分 WHERE 
条件下推到存储引擎, 在那里使用索引评估. 如果没有查找到匹配的记录, 则避免聚集索引查找. 如果找到匹配的记录, 即使是在被标记
为删除的记录中, 也会在 InnoDB 聚餐索引中查找该记录.

