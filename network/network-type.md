# Linux 基础网络设备

Bridge, 802.1.q, VLAN device, VETH, TAP

## Bridge

Bridge(网桥)是Linux上用来做TCP/IP二层协议转换的设备, 与现实世界中的交换机功能类似.

![image](resource/type-bridge.jpg)

Bridge设备实例可以和Linux上其他网络设备实例连接, 即attach一个从设备. 当有数据到达时, Bridge会根据报文中的MAC信息进行
广播, 转发, 丢弃处理.

Bridge的功能主要在内核里实现. 

当一个从设备被attach到Bridge上时,想在在内核程序里, netdev_rx_handler_register()被调用, 一个用于接受数据的回调函数
被注册. 以后**每当这个从设备收到数据时** 都会调用这个函数可以把数据转发到Bridge上.

当Bridge接收到此数据后, br_handle_frame()被调用, 进行一个和现实世界中的交换机类似的处理过程: 判断包的类别(广播/单点),
查询内部MAC端口映射表, 定位目标端口号, 将数据转发到目标端口或丢弃, 自动更新内部MAC端口映射表以自我学习.

---

- Bridge VS 二层交换机

数据可以直接发送到Bridge上, 而不是从一个端口接收. 这种状况可以看做Bridge自己有一个MAC可以主动发送报文, 或者说Bridge
自带了隐藏端口和寄主Linux系统自动连接, Linux上的程序可以直接从这个端口向Bridge上的其他端口发数据. 所以当一个Bridge拥
有了一个网络设备时, 如bridge0加入了eth0时, 实际上bridge0拥有了两个有效MAC地址, 一个是bridge0, 一个是eth0, 它们直接
可以通讯.

比较有趣的是, Bridge可以设置IP地址. 通常来说IP地址是三层协议的内容, 不应该出现在二层设备Bridge上. 但是Linux里Bridge
是通用网络抽象的一种, 只要是网络设备就能够设定IP地址.

当一个Bridge拥有IP后, Linux便可以通过路由表或者IP表规则在三层定位Bridge. 此时相当于Linux拥有了另外一个隐藏的虚拟网卡
和Bridge的隐藏端口相连.

---

- 限制 与 数据流方向

Bridge的实现当前有一个限制: 当一个设备被attach到Bridge上时, 那个设备的IP会的无效, Linux不再使用那个IP在三层接收数据.
例如: 如果eth0本来的ip是192.168.1.2, 此时如果收到一个目标地址是192.168.1.2的数据, Linux的应用程序能通过Socket操作
接收它. 而当eth0被attach到一个bridge0时, 尽管eth0的ip还存在, 但应用程序是无法接收到上述数据的. 此时应该把ip 192.168.1.2
赋予bridge0

数据流的方向. 对于一个被attach到Bridge上的设备来说, 只有它收到数据时, 此包数据才会被转发到Bridge上, 进而完成查表广播等
后续操作. 当请求是发送类型时, 数据是不会转发到Bridge上的, 它会寻找下一个发送出口. 用户在配置网络时经常忽略这一点从而造成
网络故障.

## VLAN 802.1.q

VLAN 又称虚拟网络. 此处主要说的是在物理世界中存在的, 需要协议支持的VLAN. 它的种类很多, 按照协议原理一般分为: MACVLAN
802.1.q VLAN, 802.1.qbg VLAN, 802.1.qbh VLAN.  其中出现较早, 应用广泛且比较成熟的是802.1.q VLAN, 其基本原理是
在二层协议里插入额外的VLAN协议数据(称为 802.1.q VLAN Tag), 同时保持和传统二层设备的兼容性. Linux里的VLAN设备是对
802.1.q协议的一种内部软件实现, 模拟现实世界中的802.1.q交换机.

Linux里802.1.q VLAN 设备是以母子关系成对出现的, 母设备相当于现实世界中交换机TRUNK口, 用于连接上级网络, 子设备相当于
普通接口用于连接下级网络. 

当数据在母子设备间传递时, 内核将会根据802.1.q VLAN Tag 进行对应操作.

母子设备直接是一对多的关系, 一个母设备可以有多个子设备, 一个子设备只有一个母设备.

当一个子设备有一包数据需要发送时, 数据将被加入VLAN Tag, 然后从母设备发送出去. 当母设备接收到一包数据时, 它将会分析其中
的VLAN Tag, 如果有对应的子设备存在, 则把数据转发到那个子设备上并根据设置移除VLAN Tag, 否则丢弃该数据.

在某些设置下, VLAN Tag可以不被移除以满足某些监听程序的需要, 如DHCP服务程序. 例子如下:
eth0作为母设备创建了一个ID为100的子设备eth0.100. 此时如果有程序要求从eth0.100发送一包数据, 数据将打上VLAN 100的tag
从eth0发送出去. 如果eth0收到一包数据, VLAN Tag是100, 数据将被转发到eth0.100上, 并根据设置决定是否移除VLAN Tag. 如
果eth0收到一包数据, tag是VLAN 101, 其将被丢弃.

上述过程隐含的事实: 对于寄主Linux系统来说, 母设备只能用来收数据, 子设备只能用来发送数据. 和Bridge一样, 母子设备的数据也
是有方向的, 子设备收到的数据不会进入母设备, 同样母设备上请求发送的数据不会被转发到子设备上.

注意: 母子VLAN设备拥有相同的MAC地址, 可以把它当成现实世界中802.1.q交换机的MAC, 因此多个VLAN设备会共享一个MAC. 当一个
母设备拥有多个VLAN子设备, 子设备之间是隔离的, 不存在Bridge那样交换转发关系, 原因如下: 802.1.q VLAN 协议的主要目的是
从逻辑上隔离子网. 现实世界中的802.1.q 交换机存在多个VLAN, 每个VLAN拥有很多个端口, 同一个VLAN端口之间可以交换转发, 不
同VLAN端口之间隔离, 所以其包含两层功能: 交换和隔离. Linux VLAN设备实现的是隔离功能, 没有交换功能. 一个VLAN母设备拥有
两个相同ID的VLAN子设备, 因此就不可能出现数据交换情况. 

如果想让一个VLAN里接多个设备, 就需要交换功能. 在Linux里Bridge专门实现交换功能, 因此将VLAN子设备attach到一个Bridge
上就能完成后续的交换功能. 

总结: VLAN + Bridge = 现实世界的802.1.q交换机

## TAP 和 VETH

TUN/TAP设备是一种让用户态程序向内核态协议栈注入数据的设备, 一个工作在三层, 一个工作在二层, 使用较多的是TAP设备.

VETH设备的作用是反转通讯数据的方向, 需要发送的数据被转换成需要收到的数据重新送人内核网络层进行处理, 从而间接的完成数据的
注入.

